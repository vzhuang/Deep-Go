import parsefrom multiprocessing.pool import Poolimport numpy as npimport timeimport sysclass DataSet():    def __init__(self, positions, next_moves):        passclass GameParser():    '''    Parses Game object into Tian/Zhu 2015 features    '''    def __init__(self, game):        self.game = game        self.last_move = None        self.b_to_move = True        self.b_move = 0        self.w_move = 0        # board planes - our/opponent/empty binary        self.board_planes = []        self.board_planes.append(np.zeros([19, 19])) # black        self.board_planes.append(np.zeros([19, 19])) # white        self.board_planes.append(np.ones([19, 19])) # empty        # liberty feature planes (binary true/false)        self.liberty_planes = [[np.zeros([19,19]) for x in range(3)],                               [np.zeros([19,19]) for x in range(3)]]        # # no stones have 1 liberty initially        # self.liberty_planes_b.append(np.zeros([19,19]))        # self.liberty_planes_w.append(np.zeros([19,19]))                # # 2 liberties - corners        # two = np.zeros([19, 19])        # two[0, 0] = two[18, 0] = two[0, 18] = two[18, 18] = 1        # self.liberty_planes_b.append(two)        # self.liberty_planes_w.append(two)        # # 3 or more liberties - everything except corners        # three = np.ones([19, 19])        # three[0, 0] = three[18, 0] = three[0, 18] = three[18, 18] = 0        # self.liberty_planes_b.append(three)        # self.liberty_planes_w.append(three)        # self.liberty_planes.append(self.liberty_planes_b)        # self.liberty_planes.append(self.liberty_planes_w)        self.history_planes = [np.zeros([19, 19]), np.zeros([19, 19])]        # rank planes                self.rank_planes_w = []        self.rank_planes_b = []        for i in range(9):            self.rank_planes_w.append(np.zeros([19, 19]))            self.rank_planes_b.append(np.zeros([19, 19]))        for i in range(min(int(game.rank_w), 9)):            self.rank_planes_w[i] = np.ones([19, 19])        for i in range(min(int(game.rank_b), 9)):            self.rank_planes_b[i] = np.ones([19, 19])                    self.curr_chain = set() # we only parse one chain at a time        self.ko_point = None    def extract_data_points(self):        '''        Iterates through game and returns all position, next move pairs        '''        data_points = []        if self.game.handi:            for move in self.game.handi_moves:                self.update_liberties([move])                self.add_move(move)            self.b_to_move = False        # capture size should be unchanged by handicap stones                    for i in range(self.game.num_moves):            # add all the planes to the input            inputs = []            # our/opponent liberties            # print 'move', i+1               # print 'our liberties'            if self.b_to_move:                for plane in self.liberty_planes[0]:                    inputs.append(plane)                    # print plane.T                for plane in self.liberty_planes[1]:                    inputs.append(plane)                    # print plane.T            else:                for plane in self.liberty_planes[1]:                    inputs.append(plane)                    # print plane.T                for plane in self.liberty_planes[0]:                    inputs.append(plane)                    # print plane.T            ko = np.zeros([19,19])            if self.ko_point:                ko[self.ko_point] = 1            # print 'ko'            # print ko.T            # ko             inputs.append(ko)            # our/opoonent stones/empty            # print 'board planes b/w/empty'            # print self.board_planes[0].T            # print self.board_planes[1].T            # print self.board_planes[2].T            if self.b_to_move:                inputs.append(self.board_planes[0])                inputs.append(self.board_planes[1])            else:                inputs.append(self.board_planes[1])                inputs.append(self.board_planes[0])            inputs.append(self.board_planes[2])            # print 'history b/w'            #print self.history_planes[0].T            #print self.history_planes[1].T            # # our/opponent history            if self.b_to_move:                inputs.append(self.exp(self.history_planes[0]))                inputs.append(self.exp(self.history_planes[1]))            else:                inputs.append(self.exp(self.history_planes[1]))                inputs.append(self.exp(self.history_planes[0]))            # opponent rank            if self.b_to_move:                for plane in self.rank_planes_w:                    inputs.append(plane)            else:                for plane in self.rank_planes_b:                    inputs.append(plane)            # TODO: extended features            move = (20, 20)            if self.b_to_move:                move = self.game.black_moves[self.b_move]                self.b_move += 1            else:                move = self.game.white_moves[self.w_move]                self.w_move += 1            data_points.append((inputs, move))            captured_stones = self.check_captures(move, self.get_color())            for capture in captured_stones:                self.remove(capture, self.opp_color(self.get_color()))            # print captured_stones            if len(captured_stones) == 1:                self.ko_point = move                self.add_move(move)            captured_stones.add(move)            ind = min(self.num_liberties(move, self.get_color())-1, 2)            self.liberty_planes[self.get_color()][ind][move] = 1            for i in range(3):                if i != ind:                    self.liberty_planes[self.get_color()][i][move] = 0            self.update_liberties(captured_stones)            self.update_history(move, self.get_color())            self.last_move = move            self.change_turn()        # for i in range(19):        #     for j in range(19):        #         if self.board_planes[0][i, j]:        #             print i, j, self.num_liberties((i, j), 0)        return data_points    def exp(self, plane, param = 0.1):        return np.exp(-param * plane)    def remove(self, move, color):        self.board_planes[color][move] = 0        self.board_planes[2][move] = 1        for i in range(3):            self.liberty_planes[color][i][move] = 0        self.history_planes[color][move] = 0    def opp_color(self, color):        return -1 * color + 1    def get_color(self):        if self.b_to_move:            return 0        return 1    def change_turn(self):        if self.b_to_move == True:            self.b_to_move = False        else:            self.b_to_move = True    def get_neighbors(self, position):        '''        Gets all adjacent positions        '''        neighbors = []                if position[0] > 0:            neighbors.append((position[0] - 1, position[1]))        if position[0] < 18:            neighbors.append((position[0] + 1, position[1]))        if position[1] > 0:            neighbors.append((position[0], position[1] - 1))        if position[1] < 18:            neighbors.append((position[0], position[1] + 1))        return neighbors    def add_move(self, move):        '''        adds moves to board planes, updates legality        '''        if self.b_to_move:            self.board_planes[0][move] = 1            self.board_planes[2][move] = 0        else:            self.board_planes[1][move] = 1            self.board_planes[2][move] = 0    def update_history(self, move, color):        '''        TODO: need exponentially decaying history        '''        self.history_planes[color][self.history_planes[color] > 0] += 1        # for i in range(19):        #     for j in range(19):        #         if self.history_planes[color][i, j] != 0:        #             self.history_planes[color][i, j] += 1        self.history_planes[color][move] = 1                def update_liberties(self, moves):        updated = set()        for move in moves:            for neighbor in self.get_neighbors(move):                exists = False                ncolor = 2                if self.board_planes[0][neighbor]:                    exists = True                    ncolor = 0                elif self.board_planes[1][neighbor]:                    exists = True                    ncolor = 1                if not exists:                    continue                chain = self.get_chain(neighbor, ncolor)                liberties = self.get_liberties(chain)                index = min(len(liberties) - 1, 2)                for stone in chain:                    if stone not in updated:                        self.liberty_planes[ncolor][index][stone] = 1                        for i in range(3):                            if i != index:                                self.liberty_planes[ncolor][i][stone] = 0                        updated.add(stone)    def num_liberties(self, stone, color):        '''        Returns number of liberties in chain of given stone        '''        return len(self.get_liberties(self.get_chain(stone, color)))                        def get_liberties(self, chain):        liberty_set = set()        for stone in chain:            for neighbor in self.get_neighbors(stone):                if self.board_planes[2][neighbor]:                    liberty_set.add(neighbor)        return liberty_set        def get_chain(self, stone, color):        '''        Floodfill to get all stones in chain of stone        '''        self.curr_chain = set()        self.add_to_chain(stone, color)        return self.curr_chain    def add_to_chain(self, stone, color):        '''        floodfill curr_chain        '''        if stone in self.curr_chain or \           not self.board_planes[color][stone]:                return        self.curr_chain.add(stone)        for neighbor in self.get_neighbors(stone):            self.add_to_chain(neighbor, color)                def check_captures(self, move, color):        '''        Returns set of all captured stones by a move        '''        captured_stones = set()        for neighbor in self.get_neighbors(move):            if self.board_planes[-1*color+1][neighbor] and \               self.liberty_planes[-1*color+1][0][neighbor]:                captured_stones = captured_stones.union(                    self.get_chain(neighbor, -1*color+1))        return captured_stones    def is_legal(self, move, color):        '''        NOT USED IN TIAN FEATURES        '''        # not empty?        if not self.board_planes[2][move[0]][move[1]]:             return False        # was this point just captured? (ko)        if move == self.ko_point: # TODO: update ko_point            return False        # suicide?        suicide = True        for neighbor in self.get_neighbors(move):            # move is not suicide if:            # if neighbor empty            if self.board_planes[2][neighbor]:                suicide = False            # if ally neighbor has >1 liberty            elif self.board_planes[color][neighbor]:                if num_liberties(neighbor, color) > 1:                    suicide = False            # if opponent neighbor is in atari            elif self.board_planes[-1*color+1][neighbor]:                if num_liberties(neighbor, color) == 1:                    suicide = False        if suicide:            return False        return True                def read_dataset(dir, num_threads = 4):        games = parse.get_games(dir, num_threads)    # Split KGS data according to Tian/Zhu 2015    # games before 2013 are train, after are test    print 'done'    p = Pool(processes = num_threads)    res = p.map_async(split_games, np.array_split(games, num_threads)).get(1000000)    data = []    map(data.extend, res)    p.close()    p.join()    return datadef split_games(games):    dps = []    for game in games:        gp = GameParser(game)        dps.extend(gp.extract_data_points())    return dps    def main():    start_time = time.time()    np.set_printoptions(linewidth=200)    #dir = "speedtest"    data = read_dataset(sys.argv[1], int(sys.argv[2]))    print time.time()-start_timeif __name__ == '__main__':    main()